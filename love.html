<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title>我爱你</title>
		<style>
			body {
				overflow: hidden;
				margin: 0;
				background-color: #deebfe;
			}

			h1 {
				position: fixed;
				top: 30%;
				right: 0;
				left: 0;
				margin: 0 auto;
				width: 100%;
				text-align: center;
				transform: translateY(-50%);
				font-family: 'Love Ya Like A Sister', cursive;
				font-size: 60px;
				color: #8a98a6;
				padding: 0 20px;
			}

			.mytest {
				display: none;
			}

			.fon-h3 {
				position: fixed;
				top: 60%;
				right: 0;
				left: 0;
				margin: 0 auto;
				width: 100%;
				text-align: center;
				transform: translateY(-50%);
				font-family: 'Love Ya Like A Sister', cursive;
				font-size: 40px;
				color: #8a98a6;
				padding: 0 20px;
			}
		</style>

	</head>
	<body>
		<h1 id="h1"></h1>
		<div id="source" class="mytest">
			<p>桃之夭夭，灼灼其华。<br>之子于归，宜其室家。<br>桃之夭夭，有蕡其实。<br>之子于归，宜其家室。<br>桃之夭夭，其叶蓁蓁。<br>之子于归，宜其家人。</p>
		</div>
		<div id="output" class="fon-h3">

		</div>
		<canvas></canvas>

		<script>
			window.onload = function starttime() {
				time(h1, '2022-11-27 23:26:00'); // 在一起的时间
				ptimer = setTimeout(starttime, 1000); // 添加计时器
			}

			function time(obj, futimg) {
				var nowtime = new Date().getTime(); // 现在时间转换为时间戳
				var futruetime = new Date(futimg).getTime(); // 未来时间转换为时间戳
				var msec = nowtime - futruetime; // 毫秒 未来时间-现在时间
				var time = (msec / 1000); // 毫秒/1000
				var day = parseInt(time / 86400); // 天  24*60*60*1000 
				var hour = parseInt(time / 3600) - 24 * day; // 小时 60*60 总小时数-过去的小时数=现在的小时数 
				var minute = parseInt(time % 3600 / 60); // 分 -(day*24) 以60秒为一整份 取余 剩下秒数 秒数/60 就是分钟数
				var second = parseInt(time % 60); // 以60秒为一整份 取余 剩下秒数
				obj.innerHTML = "和欣欣在一起的<br>第" + parseInt(time / 86400) + "天" + hour + "时" + minute + "分" + second + "秒"

				return true;
			}

			class Typing {
				constructor(opts) {
					this.opts = opts || {};
					this.source = opts.source;
					this.output = opts.output;
					this.delay = opts.delay || 120;
					this.chain = {
						parent: null,
						dom: this.output,
						val: []
					};
					if (!(typeof this.opts.done === 'function')) this.opts.done = function() {};
				}

				init() {
					//初始化函数
					this.chain.val = this.convert(this.source, this.chain.val);
				}

				convert(dom, arr) {
					//将dom节点的子节点转换成数组，
					let children = Array.from(dom.childNodes)
					for (let i = 0; i < children.length; i++) {
						let node = children[i]
						if (node.nodeType === 3) {
							arr = arr.concat(node.nodeValue.split('')) //将字符串转换成字符串数组，后面打印时才会一个一个的打印
						} else if (node.nodeType === 1) {
							let val = []
							val = this.convert(node, val)
							arr.push({
								'dom': node,
								'val': val
							})
						}
					}
					return arr
				}

				print(dom, val, callback) {
					setTimeout(function() {
						dom.appendChild(document.createTextNode(val));
						callback();
					}, this.delay);
				}

				play(ele) {
					//当打印最后一个字符时，动画完毕，执行done
					if (!ele.val.length) {
						if (ele.parent) this.play(ele.parent);
						else this.opts.done();
						return;
					}
					let current = ele.val.shift() //获取第一个元素，同时删除数组中的第一个元素
					if (typeof current === 'string') {
						this.print(ele.dom, current, () => {
							this.play(ele); //继续打印下一个字符
						})
					} else {
						let dom = current.dom.cloneNode() //克隆节点，不克隆节点的子节点，所以不用加参数true
						ele.dom.appendChild(dom)
						this.play({
							parent: ele,
							dom,
							val: current.val
						})
					}
				}

				start() {
					this.init();
					this.play(this.chain);
				}
			}
		</script>
		<script type="text/javascript">
			let source = document.getElementById('source')
			let output = document.getElementById('output')
			let typing = new Typing({
				source,
				output
			})
			typing.start()
		</script>

	</body>
</html>
